#!/usr/bin/env python3
# -*- encoding: utf-8; py-indent-offset: 4 -*-

# This is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# WAGNER AG
# Developer: opensource@wagner.ch

"""
Check_MK agent based checks to be used with agent_fortios Datasource

"""

from __future__ import annotations

import json
import time
from collections.abc import Mapping, Sequence
from typing import Any, Optional

from cmk.base.plugins.agent_based.agent_based_api.v1 import (
    Metric,
    Result,
    Service,
    State,
    check_levels,
    get_rate,
    get_value_store,
    register,
)
from cmk.base.plugins.agent_based.agent_based_api.v1.render import networkbandwidth
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import CheckResult, DiscoveryResult
from pydantic import BaseModel, validator


class Proxy(BaseModel):
    port: int
    protocol: int
    protocol_name: str
    subnet: str


class ProxySource(BaseModel):
    expire: Optional[int] = None
    incoming_bytes: Optional[int] = 0
    outgoing_bytes: Optional[int] = 0
    p2name: Optional[str] = None
    p2serial: int
    proxy_dst: Optional[Sequence[Proxy]] = None
    proxy_src: Optional[Sequence[Proxy]] = None
    status: Optional[str] = None


class FortiIPSec(BaseModel):
    name: str
    proxyid: Sequence[ProxySource]
    comments: Optional[str] = None
    connection_count: Optional[int] = 0
    dialup_index: Optional[int] = None
    creation_time: Optional[int] = None
    type: Optional[str] = None
    incoming_bytes: Optional[int] = 0
    outgoing_bytes: Optional[int] = 0
    parent: Optional[str] = None
    rgwy: Optional[str] = None
    rport: Optional[str] = None
    tun_id: Optional[str] = None  # IPv4
    tun_id6: Optional[str] = None  # IPv6
    username: Optional[str] = None  # IPv4
    tunnels_up: int = 0
    tunnels_down: int = 0
    tunnels_total: int = 0

    @validator("tunnels_up", always=True)
    def count_tunnels_up(cls, v, values):
        if "proxyid" in values:
            return sum(1 for proxy in values["proxyid"] if proxy.status == "up")
        return v

    @validator("tunnels_down", always=True)
    def count_tunnels_down(cls, v, values):
        if "proxyid" in values:
            return sum(1 for proxy in values["proxyid"] if proxy.status == "down")
        return v

    @validator("tunnels_total", always=True)
    def count_tunnels_total(cls, v, values):
        if "proxyid" in values:
            return len(values["proxyid"])
        return v

    @property
    def summary(self) -> str:
        return f"Type: {self.type}"


def replace_hyphens(d):
    if isinstance(d, dict):
        new_dict = {}
        for k, v in d.items():
            new_key = k.replace("-", "_")
            new_dict[new_key] = replace_hyphens(v)
        return new_dict
    elif isinstance(d, list):
        return [replace_hyphens(item) for item in d]
    else:
        return d


def get_ignored_tunnels(ipsec_tunnel, tunnel_ignored_names: list, tunnel_ignored_dst_subnet: list):
    ignored_tunnels = []

    for proxy_source in ipsec_tunnel.proxyid:
        # Add p2 tunnels matching destinations subnets to ignored tunnel list
        for proxy in proxy_source.proxy_dst:
            if proxy.subnet in tunnel_ignored_dst_subnet:
                ignored_tunnels.append(proxy_source)

        # Add p2 tunnels matching tunnel names to ignored tunnel list
        if proxy_source.p2name in tunnel_ignored_names:
            if proxy_source.p2name not in ignored_tunnels:
                ignored_tunnels.append(proxy_source)

    return ignored_tunnels


def parse_fortios_ipsec(string_table) -> Mapping[str, FortiIPSec] | None:
    try:
        json_data = json.loads(string_table[0][0])
    except ValueError:
        json_data = None
    if (forti_ipsec_tunnels := json_data[0].get("results")) in ({}, []):
        return None

    return {item["name"]: FortiIPSec(**item) for item in replace_hyphens(forti_ipsec_tunnels)}


def discovery_fortios_ipsec(section: Mapping[str, FortiIPSec]) -> DiscoveryResult:
    for item in section:
        # in case of red devices, ignore the autogenerated parent tunnels
        tunnel = section.get(item)
        if tunnel is not None and tunnel.type != "":
            yield Service(item=item)


def check_fortios_ipsec(item: str, params: Mapping[str, Any], section: Mapping[str, FortiIPSec]) -> CheckResult:
    if (ipsec_tunnel := section.get(item)) is None:
        yield Result(
            state=State.UNKNOWN,
            summary=f"Tunnel {item} is missing",
        )
        return

    tunnel_ignored_names = params.get("fortios_tunnels_ignore", [])
    tunnel_ignored_dst_subnet = params.get("fortios_tunnels_dst_subnet_ignore", [])

    ignored_tunnels = get_ignored_tunnels(ipsec_tunnel, tunnel_ignored_names, tunnel_ignored_dst_subnet)

    details = f"""Tunnels up: [{", ".join([f"{proxy.p2name}: {[dest.subnet for dest in proxy.proxy_dst]}" for proxy in ipsec_tunnel.proxyid if proxy.status == "up"])}], \n
                Tunnels down: [{", ".join([f"{proxy.p2name}: {[dest.subnet for dest in proxy.proxy_dst]}" for proxy in ipsec_tunnel.proxyid if proxy.status == "down"])}], \n
                Tunnels ignored by name: [{", ".join(tunnel_ignored_names)}], \n
                Tunnels ignored by destination subnet: [{", ".join(tunnel_ignored_dst_subnet)}], \n
                """

    if ipsec_tunnel.tunnels_up == ipsec_tunnel.tunnels_total:
        yield Result(state=State.OK, summary=ipsec_tunnel.summary, details=details)

    elif any(str(proxy_source.p2name) == (ipsec_tunnel.proxyid[0].p2name) for proxy_source in ignored_tunnels):
        yield Result(state=State.OK, summary=ipsec_tunnel.name, details=details)
    else:
        yield Result(state=State.CRIT, summary=ipsec_tunnel.summary, details=details)

    yield from check_levels(
        value=ipsec_tunnel.tunnels_total,
        metric_name="ipsec_total",
        label="Total",
    )
    yield Metric("total_tunnels", ipsec_tunnel.tunnels_total)

    yield from check_levels(
        value=ipsec_tunnel.tunnels_up,
        metric_name="ipsec_up",
        label="Up",
    )
    yield Metric("ipsec_up", ipsec_tunnel.tunnels_up)

    yield from check_levels(
        value=ipsec_tunnel.tunnels_down,
        metric_name="ipsec_down",
        label="Down",
    )

    yield Metric("ipsec_down", ipsec_tunnel.tunnels_down)

    yield from check_levels(
        value=len(ignored_tunnels),
        metric_name="ipsec_ignored",
        label="Ignored",
    )

    yield Metric("ipsec_ignored", len(ignored_tunnels))

    yield from check_levels(
        value=ipsec_tunnel.connection_count,
        metric_name="ipsec_connections",
        label="Connection count",
    )
    yield Metric("ipsec_connections", ipsec_tunnel.connection_count)

    value_store = get_value_store()
    if ipsec_tunnel.incoming_bytes:
        act_time = time.time()
        incoming_bytes = 0
        incoming_bytes = get_rate(value_store, "if_in_bps", act_time, ipsec_tunnel.incoming_bytes)
        yield from check_levels(
            value=incoming_bytes,
            metric_name="if_in_bps",
            render_func=networkbandwidth,
            label="In",
        )
        yield Metric("if_in_bps", value=incoming_bytes)

    if ipsec_tunnel.outgoing_bytes:
        act_time = time.time()
        outgoing_bytes = 0
        outgoing_bytes = get_rate(value_store, "if_out_bps", act_time, ipsec_tunnel.outgoing_bytes)
        yield from check_levels(
            value=outgoing_bytes,
            metric_name="if_out_bps",
            render_func=networkbandwidth,
            label="Out",
        )
        yield Metric("if_out_bps", value=outgoing_bytes)


register.agent_section(
    name="fortios_ipsec",
    parse_function=parse_fortios_ipsec,
)

register.check_plugin(
    name="fortios_ipsec",
    service_name="VPN IPSec Tunnel %s",
    discovery_function=discovery_fortios_ipsec,
    check_ruleset_name="fortios_ipsec",
    check_default_parameters={},
    check_function=check_fortios_ipsec,
)
